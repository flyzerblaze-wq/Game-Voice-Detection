<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Spell Companion</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #667eea 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 40px;
            max-width: 600px;
            width: 100%;
            text-align: center;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            color: white;
            margin-bottom: 30px;
            font-size: 2.8em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .status-container {
            margin: 30px 0;
        }

        .status {
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            font-weight: bold;
            font-size: 18px;
            transition: all 0.4s ease;
            border: 2px solid transparent;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status.ready {
            background: rgba(33, 150, 243, 0.2);
            color: #2196F3;
            border-color: #2196F3;
        }

        .status.listening {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
            border-color: #4CAF50;
            animation: pulse 2s infinite;
        }

        .status.processing {
            background: rgba(255, 193, 7, 0.3);
            color: #FFC107;
            border-color: #FFC107;
            animation: shimmer 1.5s infinite;
        }

        .status.error {
            background: rgba(244, 67, 54, 0.3);
            color: #f44336;
            border-color: #f44336;
        }

        .status.success {
            background: rgba(76, 175, 80, 0.3);
            color: #4CAF50;
            border-color: #4CAF50;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
            50% { transform: scale(1.02); box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
        }

        @keyframes shimmer {
            0% { background-position: -200px 0; }
            100% { background-position: 200px 0; }
        }

        .controls {
            margin: 30px 0;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 18px 35px;
            border-radius: 50px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
            min-width: 160px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.3);
        }

        button:active:not(:disabled) {
            transform: translateY(-1px);
        }

        button:disabled {
            background: linear-gradient(45deg, #999, #666);
            cursor: not-allowed;
            transform: none;
            opacity: 0.6;
        }

        button.listening {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            animation: buttonPulse 2s infinite;
        }

        @keyframes buttonPulse {
            0%, 100% { box-shadow: 0 8px 20px rgba(255, 107, 107, 0.4); }
            50% { box-shadow: 0 8px 30px rgba(255, 107, 107, 0.8); }
        }

        .spell-detection {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .spell-detection h3 {
            color: white;
            margin-bottom: 20px;
            font-size: 1.4em;
        }

        .confidence-meter {
            background: rgba(0, 0, 0, 0.2);
            height: 10px;
            border-radius: 5px;
            margin: 15px 0;
            overflow: hidden;
        }

        .confidence-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            border-radius: 5px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .live-transcript {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            min-height: 50px;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .spell-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .spell-badge {
            background: linear-gradient(45deg, #ffecd2, #fcb69f);
            color: #333;
            padding: 12px 16px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            cursor: pointer;
        }

        .spell-badge:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .spell-badge.detected {
            background: linear-gradient(45deg, #a8edea, #fed6e3);
            border-color: #4CAF50;
            animation: spellGlow 1s ease-in-out;
        }

        @keyframes spellGlow {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .spell-log {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 25px;
            max-height: 250px;
            overflow-y: auto;
            text-align: left;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .spell-log h4 {
            color: white;
            margin-bottom: 15px;
            text-align: center;
        }

        .log-entry {
            color: white;
            margin: 12px 0;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border-left: 4px solid #4ecdc4;
            font-size: 14px;
            animation: fadeIn 0.5s ease-in;
        }

        .log-entry.success {
            border-left-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }

        .log-entry.error {
            border-left-color: #f44336;
            background: rgba(244, 67, 54, 0.1);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .browser-support {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #FFC107;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            color: #FFC107;
            font-size: 14px;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                padding: 25px;
                margin: 10px;
            }
            
            h1 {
                font-size: 2.2em;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 100%;
                max-width: 280px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîÆ Voice Spell Caster</h1>
        
        <div class="status-container">
            <div id="status" class="status ready">
                üéØ Ready to detect spells! Click "Start Listening" to begin.
            </div>
        </div>

        <div class="controls">
            <button id="startBtn" onclick="startListening()">
                <span id="startBtnText">üé§ Start Listening</span>
            </button>
            <button id="stopBtn" onclick="stopListening()" disabled>
                ‚èπÔ∏è Stop Listening
            </button>
            <button id="testBtn" onclick="testVoice()">
                üîß Test Voice
            </button>
        </div>

        <div class="spell-detection">
            <h3>üéØ Voice Detection</h3>
            
            <div class="live-transcript" id="liveTranscript">
                Speak clearly and say spell names...
            </div>
            
            <div style="color: white; margin: 10px 0;">Confidence Level:</div>
            <div class="confidence-meter">
                <div class="confidence-bar" id="confidenceBar"></div>
            </div>

            <h3 style="margin-top: 25px;">‚ú® Available Spells</h3>
            <div class="spell-grid" id="spellGrid">
                <div class="spell-badge" data-spell="fireball">üî• Fireball</div>
                <div class="spell-badge" data-spell="heal">üíö Heal</div>
                <div class="spell-badge" data-spell="lightning">‚ö° Lightning</div>
                <div class="spell-badge" data-spell="shield">üõ°Ô∏è Shield</div>
                <div class="spell-badge" data-spell="teleport">üåÄ Teleport</div>
                <div class="spell-badge" data-spell="iceblast">‚ùÑÔ∏è Ice Blast</div>
            </div>
        </div>

        <div class="spell-log">
            <h4>üìú Spell Detection Log</h4>
            <div id="logContainer">
                <div class="log-entry">Voice Spell Companion loaded! Speak clearly for best results.</div>
            </div>
        </div>

        <div class="browser-support" id="browserWarning" style="display: none;">
            ‚ö†Ô∏è For best results, use Chrome, Edge, or Safari. Make sure to allow microphone access!
        </div>
    </div>

    <script>
        // Enhanced Voice Recognition System
        class VoiceSpellCaster {
            constructor() {
                this.recognition = null;
                this.isListening = false;
                this.isSupported = false;
                this.hasError = false;
                this.finalTranscript = '';
                this.interimTranscript = '';
                this.startAttempts = 0;
                this.maxStartAttempts = 3;
                
                // Spell configurations with multiple variations
                this.spells = {
                    fireball: {
                        variations: ['fireball', 'fire ball', 'fire', 'flame', 'burn'],
                        emoji: 'üî•',
                        name: 'Fireball'
                    },
                    heal: {
                        variations: ['heal', 'healing', 'cure', 'restore', 'health'],
                        emoji: 'üíö',
                        name: 'Heal'
                    },
                    lightning: {
                        variations: ['lightning', 'thunder', 'bolt', 'electric', 'shock'],
                        emoji: '‚ö°',
                        name: 'Lightning'
                    },
                    shield: {
                        variations: ['shield', 'protect', 'defense', 'barrier', 'guard'],
                        emoji: 'üõ°Ô∏è',
                        name: 'Shield'
                    },
                    teleport: {
                        variations: ['teleport', 'portal', 'warp', 'travel', 'transport'],
                        emoji: 'üåÄ',
                        name: 'Teleport'
                    },
                    iceblast: {
                        variations: ['ice blast', 'ice', 'freeze', 'frost', 'cold'],
                        emoji: '‚ùÑÔ∏è',
                        name: 'Ice Blast'
                    }
                };

                this.lastDetectedSpell = null;
                this.detectionCooldown = 2000; // 2 seconds between same spell detections
                
                this.init();
            }

            init() {
                this.checkBrowserSupport();
                this.setupRecognition();
                this.bindEvents();
                this.log('System initialized. Ready for voice commands!');
            }

            checkBrowserSupport() {
                if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                    this.isSupported = true;
                    this.log('‚úÖ Speech recognition supported!', 'success');
                } else {
                    this.isSupported = false;
                    this.updateStatus('‚ùå Speech recognition not supported in this browser', 'error');
                    document.getElementById('browserWarning').style.display = 'block';
                    this.log('‚ùå Speech recognition not supported. Please use Chrome, Edge, or Safari.', 'error');
                }
            }

            async setupRecognition() {
                if (!this.isSupported) return;

                // First, request microphone permission explicitly
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream.getTracks().forEach(track => track.stop()); // Stop the stream, we just needed permission
                    this.log('‚úÖ Microphone permission granted', 'success');
                } catch (error) {
                    this.log('‚ùå Microphone permission denied: ' + error.message, 'error');
                    this.updateStatus('‚ùå Please allow microphone access and refresh the page', 'error');
                    return;
                }

                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                this.recognition = new SpeechRecognition();

                // Enhanced configuration
                this.recognition.continuous = true;
                this.recognition.interimResults = true;
                this.recognition.lang = 'en-US';
                this.recognition.maxAlternatives = 1; // Reduced to prevent issues

                this.recognition.onstart = () => {
                    this.isListening = true;
                    this.updateStatus('üé§ Listening for spells... Speak clearly!', 'listening');
                    this.updateButtons();
                    this.log('üé§ Voice recognition started', 'success');
                };

                this.recognition.onresult = (event) => {
                    this.processResults(event);
                };

                this.recognition.onerror = (event) => {
                    this.handleError(event);
                };

                this.recognition.onend = () => {
                    // Only auto-restart if we're supposed to be listening AND it wasn't an error
                    if (this.isListening && !this.hasError) {
                        setTimeout(() => {
                            if (this.isListening && !this.hasError) {
                                try {
                                    this.recognition.start();
                                } catch (e) {
                                    this.log('Auto-restart failed: ' + e.message, 'error');
                                    this.stopListening();
                                }
                            }
                        }, 500); // Increased delay to prevent spam
                    } else {
                        this.stopListening();
                    }
                };
            }

            processResults(event) {
                let interim = '';
                let final = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript.toLowerCase().trim();
                    const confidence = event.results[i][0].confidence;

                    if (event.results[i].isFinal) {
                        final += transcript + ' ';
                        this.finalTranscript = final;
                    } else {
                        interim += transcript + ' ';
                        this.interimTranscript = interim;
                    }

                    // Update confidence meter
                    this.updateConfidence(confidence || 0);
                }

                // Update live transcript
                const display = final + (interim ? `<span style="opacity: 0.6;">${interim}</span>` : '');
                document.getElementById('liveTranscript').innerHTML = display || 'Listening...';

                // Check for spells in both final and interim results
                const textToCheck = (final + interim).toLowerCase();
                this.detectSpells(textToCheck);
            }

            detectSpells(text) {
                for (const [spellKey, spellData] of Object.entries(this.spells)) {
                    for (const variation of spellData.variations) {
                        if (text.includes(variation)) {
                            this.castSpell(spellKey, spellData, variation);
                            return; // Only cast one spell at a time
                        }
                    }
                }
            }

            castSpell(spellKey, spellData, detectedWord) {
                // Cooldown check
                const now = Date.now();
                if (this.lastDetectedSpell && 
                    this.lastDetectedSpell.spell === spellKey && 
                    now - this.lastDetectedSpell.time < this.detectionCooldown) {
                    return; // Too soon to cast same spell again
                }

                this.lastDetectedSpell = { spell: spellKey, time: now };

                // Visual feedback
                this.highlightSpell(spellKey);
                this.updateStatus(`üîÆ Detected: ${spellData.emoji} ${spellData.name}!`, 'success');
                
                // Log the detection
                this.log(`${spellData.emoji} Detected "${detectedWord}" ‚Üí Casting ${spellData.name}!`, 'success');

                // Simulate spell casting (replace with actual Roblox connection later)
                setTimeout(() => {
                    if (this.isListening) {
                        this.updateStatus('üé§ Listening for spells... Speak clearly!', 'listening');
                    }
                }, 2000);
            }

            highlightSpell(spellKey) {
                // Remove previous highlights
                document.querySelectorAll('.spell-badge').forEach(badge => {
                    badge.classList.remove('detected');
                });

                // Highlight detected spell
                const badge = document.querySelector(`[data-spell="${spellKey}"]`);
                if (badge) {
                    badge.classList.add('detected');
                    setTimeout(() => badge.classList.remove('detected'), 2000);
                }
            }

            updateConfidence(confidence) {
                const percentage = Math.round(confidence * 100);
                document.getElementById('confidenceBar').style.width = percentage + '%';
            }

            handleError(event) {
                this.hasError = true;
                let errorMessage = 'Voice recognition error: ';
                
                switch(event.error) {
                    case 'no-speech':
                        errorMessage += 'No speech detected. Try speaking louder.';
                        this.hasError = false; // This is recoverable
                        break;
                    case 'audio-capture':
                        errorMessage += 'Microphone not accessible. Check permissions.';
                        break;
                    case 'not-allowed':
                        errorMessage += 'Microphone permission denied. Please refresh and allow access.';
                        break;
                    case 'network':
                        errorMessage += 'Network error. Check internet connection.';
                        this.hasError = false; // This is recoverable
                        break;
                    case 'aborted':
                        errorMessage += 'Speech recognition aborted.';
                        this.hasError = false; // User might have clicked stop
                        break;
                    default:
                        errorMessage += event.error;
                }

                this.log(errorMessage, 'error');
                this.updateStatus('‚ùå ' + errorMessage, 'error');
                
                // Only auto-retry for truly recoverable errors and if we haven't tried too many times
                if (!this.hasError && this.isListening && this.startAttempts < this.maxStartAttempts) {
                    this.startAttempts++;
                    setTimeout(() => {
                        if (this.isListening && !this.hasError) {
                            this.log(`Retrying voice recognition... (attempt ${this.startAttempts}/${this.maxStartAttempts})`, 'success');
                            try {
                                this.recognition.start();
                            } catch (e) {
                                this.log('Retry failed: ' + e.message, 'error');
                                this.stopListening();
                            }
                        }
                    }, 2000);
                } else {
                    this.stopListening();
                }
            }

            startListening() {
                if (!this.isSupported) {
                    this.updateStatus('‚ùå Speech recognition not supported', 'error');
                    return;
                }

                if (this.isListening) {
                    this.log('Already listening, ignoring start request', 'error');
                    return;
                }

                this.hasError = false;
                this.startAttempts = 0;

                try {
                    this.finalTranscript = '';
                    this.interimTranscript = '';
                    this.recognition.start();
                    this.log('Starting voice recognition...', 'success');
                } catch (error) {
                    this.log('Failed to start: ' + error.message, 'error');
                    this.updateStatus('‚ùå Failed to start voice recognition', 'error');
                    
                    // If we get "already started" error, force stop and try again
                    if (error.message.includes('already') || error.message.includes('started')) {
                        this.recognition.stop();
                        setTimeout(() => {
                            try {
                                this.recognition.start();
                            } catch (e) {
                                this.log('Restart failed: ' + e.message, 'error');
                            }
                        }, 1000);
                    }
                }
            }

            stopListening() {
                this.isListening = false;
                this.hasError = false;
                this.startAttempts = 0;
                
                if (this.recognition) {
                    try {
                        this.recognition.stop();
                    } catch (error) {
                        // Ignore errors when stopping
                    }
                }
                
                this.updateStatus('üéØ Ready to detect spells! Click "Start Listening" to begin.', 'ready');
                this.updateButtons();
                document.getElementById('liveTranscript').innerHTML = 'Speak clearly and say spell names...';
                document.getElementById('confidenceBar').style.width = '0%';
                this.log('Voice recognition stopped', 'success');
            }

            async testVoice() {
                if (this.isListening) {
                    this.log('Please stop listening first before testing', 'error');
                    return;
                }

                this.log('üîß Testing voice recognition...', 'success');
                this.updateStatus('üîß Say "Hello test" to verify your microphone...', 'processing');
                
                if (!this.isSupported) {
                    this.updateStatus('‚ùå Speech recognition not supported', 'error');
                    return;
                }

                try {
                    // Quick permission check first
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream.getTracks().forEach(track => track.stop());

                    // Quick test
                    const testRecognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                    testRecognition.continuous = false;
                    testRecognition.interimResults = false;
                    testRecognition.lang = 'en-US';

                    testRecognition.onresult = (event) => {
                        const result = event.results[0][0].transcript;
                        this.log(`‚úÖ Test successful! Heard: "${result}"`, 'success');
                        this.updateStatus('‚úÖ Microphone working! Ready for spells.', 'success');
                    };

                    testRecognition.onerror = (event) => {
                        this.log(`‚ùå Test failed: ${event.error}`, 'error');
                        this.updateStatus('‚ùå Microphone test failed', 'error');
                    };

                    testRecognition.onend = () => {
                        setTimeout(() => {
                            if (!this.isListening) {
                                this.updateStatus('üéØ Ready to detect spells! Click "Start Listening" to begin.', 'ready');
                            }
                        }, 3000);
                    };

                    testRecognition.start();
                } catch (error) {
                    this.log(`‚ùå Permission error: ${error.message}`, 'error');
                    this.updateStatus('‚ùå Please allow microphone access', 'error');
                }
            }

            updateStatus(message, type) {
                const statusEl = document.getElementById('status');
                statusEl.textContent = message;
                statusEl.className = `status ${type}`;
            }

            updateButtons() {
                const startBtn = document.getElementById('startBtn');
                const stopBtn = document.getElementById('stopBtn');
                const startText = document.getElementById('startBtnText');

                if (this.isListening) {
                    startBtn.disabled = true;
                    startBtn.classList.add('listening');
                    startText.textContent = 'üé§ Listening...';
                    stopBtn.disabled = false;
                } else {
                    startBtn.disabled = false;
                    startBtn.classList.remove('listening');
                    startText.textContent = 'üé§ Start Listening';
                    stopBtn.disabled = true;
                }
            }

            log(message, type = 'info') {
                const logContainer = document.getElementById('logContainer');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                
                logContainer.appendChild(entry);
                logContainer.scrollTop = logContainer.scrollHeight;

                // Keep only last 10 entries
                while (logContainer.children.length > 10) {
                    logContainer.removeChild(logContainer.firstChild);
                }
            }

            bindEvents() {
                // Allow clicking spell badges to test detection
                document.querySelectorAll('.spell-badge').forEach(badge => {
                    badge.addEventListener('click', () => {
                        const spellKey = badge.dataset.spell;
                        const spellData = this.spells[spellKey];
                        this.log(`üñ±Ô∏è Manual test: ${spellData.name}`, 'success');
                        this.castSpell(spellKey, spellData, 'manual click');
                    });
                });
            }
        }

        // Global functions for buttons
        let voiceCaster;

        function startListening() {
            voiceCaster.startListening();
        }

        function stopListening() {
            voiceCaster.stopListening();
        }

        function testVoice() {
            voiceCaster.testVoice();
        }

        // Initialize when page loads
        window.addEventListener('load', () => {
            voiceCaster = new VoiceSpellCaster();
        });
    </script>
</body>
</html>
